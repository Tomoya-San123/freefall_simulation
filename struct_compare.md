# 構造体細工の考察

## 動作
コードの概観としては、Obj構造体h1を元にそのコピーをh2とし、細工前後でh1とh2のメモリ内容を比較するものとなっている。内容が一致すればtrue、一致しなければfalseとなる。<br><br>
実行してみると次のように出力される。

```
(1.000000 1.000000)
(2.000000 2.000000)
(c c)
true
(1.000000 1.000000)
(2.000000 2.000000)
(c c)
false
```

trick()が実行される前後で構造体h2は一見変化していないように見えるが、以下のコードでメモリの内容を比較すると細工後にはh1と一致していないことがわかる。

```
printf("%s\n", (!memcmp(&h1,&h2,sizeof(Obj)))?"true":"false");
```

---

## trick()の仕掛け
我々の目には見えていないところで何かしらの変化があったと予想し、真っ先にパディングを疑った。特に、1バイトのchar型が構造体のメンバに含まれていたので、なおさら怪しかった。<br>
このままでは、パディングの内容物にアクセスできないので、h2.bに対するポインタh2_ptrを定義した。<br>
そして、以下のコードを追加することで、パディングの内容物を表示した。
```
for(int i = 1; i < 8; i++) {
        printf("byte no.%d = %hhd\n", i, *(h2b_ptr+i));
    }
```
こちらが、実行結果である。
```
Before trick
byte no.1 = 0
byte no.2 = 0
byte no.3 = 0
byte no.4 = 0
byte no.5 = 0
byte no.6 = 0
byte no.7 = 0
----------------------------
After trick
byte no.1 = h
byte no.2 = e
byte no.3 = l
byte no.4 = l
byte no.5 = o
byte no.6 =  
byte no.7 = 
```
この結果からメンバbの7バイト分のパディングがもともとは0詰めされていたのに対し、細工後にはhelloという文字列が代入されたことがわかる。

---

## 構造体比較の注意点
この課題からわかったように、memcmp()を用いて構造体が占める全メモリ領域を比較してしまうと、パディングがあった場合に不具合が生じる。<br>
特にパディングの内容物と数は環境等によって異なるので、この関数を使用するのは避けなければならい。<br>
このパディングビットの値への影響を無視するためには、構造体のメンバ動詞を逐次比較することが一般的となっている。<br>
