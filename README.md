# 第2回課題　物理シミュレーション

## 課題1 (struct_alignment.c)

- 同封のstruct_alignment.mdを参照
<br><br>
---

## 課題２ (struct_compare.c)
- 同封のstruct_compare.mdを参照
<br><br>
---

## 課題3 (my_bouncing1.c)

### 反射
- 壁の座標ぴったりで衝突判定を行うと、トンネル効果が生じるので、変数marginで余裕を持たせた。
- marginを定数にしてしまうと、壁や床付近での物体の速度によって、なおトンネル効果が生じてしまうので、91、92行目のようにmarginを1ステップでの変位の半分と定数の和で定義した。

```
margin_y = fabs(objs[i].y - objs[i].prev_y) / 2 + 0.2;
margin_x = fabs(objs[i].x - objs[i].prev_x) / 2 + 0.2;
```

- 衝突後の速度変化を行う時は、壁床付近での速度が十分に小さいと、振動を起こしてしまうので、衝突変化は物体の位置に加えてその速度の正負を条件として設定して防いだ。（93~100行目を参照）
- 壁付近では物体が消滅しやすいので、ある程度のmarginを持たせて座標としては壁を通過していても端のマスに表示するようにした。
<br><br>
---

### 多体拡張
- my_update_positions()とmy_update_velocities()に関しては、物体の数を増やしても対応できるように、for文で行った。
- 今回は地球以外の軽い物体動詞の万有引力は無視し、物体地球の距離は、そのy座標だけで考えることとした。(195行目〜)
<br><br>
---

### その他工夫点
- my_plot_objects()では表示する速度を右詰で行うことで、見やすくした。(186行目)

```
printf("objs[%d].y = %7.2f, objs[%d].x = %7.2f\n", i, objs[i].y, i, objs[i].x);

```
- 挙動がわかりやすいので、sleepで20ms毎に更新することにした。(75行目)
<br><br>
---

## 課題4 (my_bouncing2.c)

### 初期値設定
- 新たにmy_init_objects()を実装した。
- .datファイルが指定されていなければ、デフォルトで物体の数4を出力し、.datファイルが指定されていれば、コマンドラインで指定した物体数と、ファイルに記述されている物体数の少ない方を出力する。
- これ以降は、正しい物体数がobjnumに渡されるので、わざわざ空の物体を作る必要はない。
<br><br>
以下のように実行することで確かめることができる。

```
./my_bouncing2 5 my_data.dat
```

<br>

---

### 万有引力の設定
- my_update_velocities()では距離の近似をせずに実際値を使うように拡張した。
- また、小さい物体同士の万有引力を考慮すると、カオスな状態になってしまうので、質量差を条件として無視することで意味のあるシミュレーションにした。
<br><br>
---

## 課題5 (my_bouncing3.c)

### 物体同士の衝突

- 新たに衝突を判定して再現する関数であるmy_collision()を実装した。
- 簡単のために完全弾性衝突として、運動量保存則と反発係数1の関係から計算を行った。
<br><br>
以下のように引数なしで実行すると、デフォルトで物体同士が衝突する挙動が見られる。
```
./my_bouncing.c
```

<br>

---

## 課題6 惑星の公転 (my_bouncing4.c)

- 中央には大きな恒星があり、その周りを惑星が公転している様子をシミュレーションした。
- 惑星同士の万有引力は無視し、恒星との万有引力のみを考えた。
- フォントの縦横比が原因で楕円的な軌道を描いているが、引き伸ばせばほとんど円になりそうである。
- 円運動の物理式からある程度のパラメータの検討はつけつつ、何度も実行してチューニングすることで、運動がある程度枠内に収まるようになった。
